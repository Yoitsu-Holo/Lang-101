# 函数

在学习函数之前，我们先~~预习~~复习一下之前的程序三种基本控制结构的大概内容

![[-22f216a640b32156_edit_5067927013288.jpg]]
## 什么是函数

函数是指一段可以直接被另一段程序或代码引用的程序或代码

一个较大的程序一般应分为若干个程序块，每一个模块用来实现一个特定的功能。所有的高级语言中都有子程序这个概念，用子程序实现模块的功能。在C语言中，子程序的作用是由一个主函数和若干个函数构成。由主函数调用其他函数，其他函数也可以互相调用

同一个函数可以被**一个或多个函数调用任意多次**。在程序设计中，常将一些常用的功能模块编写成函数

其实在前面的学习中，我们已经接触到了一些函数

最直接的就是输入输出函数：printf和scanf

显然，我们使用了这些函数，而这些函数也实现了他们对应的功能，例如输入函数scanf将终端中输入的数据转移到代码中，printf则将数据在终端中输出出来

并且对于带有返回值的函数，其计算的得到的值会返回给调用它的地方

函数我们通常使用下列语句来定义：
```cpp
返回值类型 函数名称(参数表)
{
    //中间过程
    return 返回值;
}
```

首先要知道，函数有两种基本类型，一种是包含返回值的，这时在函数的开头一定要写上返回值的具体类型，这个类型可以是系统自带的，也可以是自己定义的结构体或类，并且在return后面也要返回和这个返回值类型匹配的变量

第二种是没有返回值的，其应当在函数定义时写上void，并且return后面不加任何值，直接打分号

## 函数名称和中间过程

中间过程自然不用说，这和你们之前写的是一样的（你们之前是在main函数中写的代码，main 函数也是一个函数）

而函数名称和我们的变量取名的规则一样，使用字母，数字下划线起名，并且不能以数字开头

### 参数表

函数的内容较为复杂，我们在此将返回值类型，参数表，返回值，局部/全局变量分开讲解

先让我们做一个规定，目前的返回值类型只能是int

如果我们需要做一个能计算整数阶乘的函数，就可以采取以下方法
```cpp
int func(int x) {
    int ans = 1;
    while (x)
        ans *= x--;
    return ans;
}
```

又或者我们需要传入两个参数（返回两个数中较大的值）
```cpp
int max(int x, int y) {
    if (x > y)
        return x;
	else
	    return y;
}
```

将上述两个函数放在一起，可以看出，两个函数的参数表的参数数量是不一样的，对于第一个函数而言，我们只需要计算一个数的阶乘，于是我们就在参数表中定义了一个参数x，而对于第二个函数而言，我们需要求解两个数中较大的那一个，自然我们也需要两个参数，并且参数传入的位置是和调用位置一一对应的

例如比大小的例子中，如果我调用的是max(1,4)，那么传入函数时，x的值就是1，y的值就是4

同理，如果我们需要计算一个立方体的体积，我们要传入的就应当是这个立方体的长宽高三个信息，所以自然需要在参数表中拟定三个参数

当然，也可以传入底面面积和高，这时就仅需两个参数

参数表中的参数类型（形参）应当和实际传入的参数类型（实参）匹配，以免出错，例如我们要传入实数时，函数的当前位置就应当是一个实数，而非整数，如果否则函数将执行变量的隐式转化

## 返回值

如果我们需要求解一个实数的整数次方应该如何求解，显然我们的函数的参数表中应该有一个浮点数和整数类型

按照上面代码葫芦画瓢，容易写出：
```cpp
int power(double a, double b) {
    double temp = 1;
    while (b) {
        temp *= a;
        b--;
    }
    return temp;
}
```

但是在实际运行的发现，如果我们调用power(1.5,2)时，期望的返回结果应当是2.25，但是实际的返回结果是2

了解浮点数隐式转化整数规则的同学肯定已经想到，这里的2其实就是2.25执行了隐式转化后的结果

在看我们函数的返回值类型为int，不难想到这与返回值的类型有关

在猜测到原因后，我们可以尝试修改代码，将函数的返回值类型改为double
```cpp
double power(double a, double b) {
    double temp = 1;
    while (b) {
        temp *= a;
        b--;
    }
    return temp;
}
```

这时再进行调用，那么可以得到返回结果为2.25

期望与事实相符

到此，已经对于返回值类型的作用有了一个大致的了解，以便于我们的深入讨论

函数的返回值分为两种，一种是具有实际的返回值，一种没有返回值

有返回值的类型通过上面的例子相信应该也能够有所了解

没有返回值的类型在函数的开头将原本写返回值类型的地方换成void即可，return的时候不跟任何东西直接加分号

例如：
```cpp
void hello() {
	printf("Hello World!\n");
	return;
}
```

特别的，如果你在函数的最后才返回，那么你可以省略掉最后一行的return

## 函数的返回

对于一个函数来说，返回的地方有两种，一种是执行到了return所在的位置，还有一种是针对无返回值函数而言，在函数的最后会自动返回

注意，这里遇到return就立刻返回到调用他的位置了，而不会再执行剩下的代码，如下：

```cpp
void returnTest(int x) {
	printf("1");
	if(x==1)
		return;
	printf("2");
}
```

我们调整传入里面的参数

如果我们调用returnTest(1);我们的运行结果为1
如果是returnTest(2);或者其他，我们运行结果是12

这个实验很好解释了return时返回和无返回值函数在代码最后返回

同时，函数也可以再任何位置，任何时候返回，例如以下代码：
![[Pasted image 20220809140448.png]]

其在满足不同条件是的返回值是不一样的

而且可以看到，在函数内部也是可以调用其他函数以及这个函数自身（最后一行）

## 常用的库函数

由于函数较多，同学们可以自行百度搜索“C++常用库函数”
或者上C++官网

[cplusplus](http://www.cplusplus.com/)
[cppReference](https://en.cppreference.com/w/cpp/standard_library)
查询

# 递归（得慢慢理解）

上面我们讲解了函数，这里我们将继续深入讲解函数的另外一种使用技巧——递归

用官方一点的话来说：程序调用自身的编程技巧称为递归

而在C++中函数内部调用自身的过程我们就称为递归的过程

说的简单一点，就是函数自身不停的套娃
![[Pasted image 20220809141101.png]]
递归的实现方式其实非常简单

前面已经说了，递归的过程其实就是函数自身调用的过程

那么我们就在这个函数里面调用这个函数，这样就能实现递归了

例如这样：
```cpp
void func() {
	//...
	func();
	//...
}
```

正是由于递归具有了能够自身调用自身的特性，所以我们一定要保证，递归到某一种边界情况时必须会返回，否者程序将一直递归下去，造成内存使用量过大而崩溃（函数的信息是存放在栈空间中，过多的递归调用会导致栈空间耗尽，而爆栈空间）

所以，我们通常会限制递归时自身调用自身的次数，在这里我们将其称为深度

下面我们用代码的方式来实例化讲解
```cpp
void dfs(int deep) {
    printf("deep=%d\n", deep);
    if (deep == 5)
        return;
    printf("in:\n");
    dfs(deep + 1);
    printf("out:\n");
}
```

我们可以从代码中看到，我们每一次进入这个函数，我们先让其输出deep的值，然后判断deep是否等于5，如果等于5的话就直接返回，否者执行下一步操作

而对于小于5的情况，在调用 dfs 前输出 in ，调用后输出 out

那么我们执行这个程序，dfs(1) 能得到如下结果：
```txt
deep=1
in:
deep=2
in:
deep=3
in:
deep=4
in:
deep=5
out:
out:
out:
out:
```

那么我们可以画出这个递归的调用/返回关系，看看具体是怎么执行的
![[10-递归.gif]]

# 总结

至此，我们的基础语法课程就已经讲解完毕，如果你还有不懂的地方，请一定在国庆节之前搞懂搞明白。

每周留下的作业做完了也不要去玩，多去练习练习，提升代码熟练度（找感觉，感觉到位了很多时候就能出答案），洛谷、vj、AtCoder、CodeForces都是很好的练习平台。

![[7190ba3160256f96.jpg]]

最后再强调一遍，比赛的时候一定不要作弊！！！