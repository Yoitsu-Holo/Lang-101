# 结构体

结构体是由一批数据组合而成的结构型数据。组成结构型数据的每个数据称为结构型数据的“成员” ，其描述了一块内存区间的大小及解释意义

在C++中这些成员可以是前面讲到过的变量（成员变量），也可以是后面即将要讲到的函数（成员函数）

这里特意强调是C++能封装函数的原因是因为C++是OOP语言，具有OOP的特性，而传统的C是面向过程的语言，不具有OOP特性，如果要封装函数需要使用函数指针（由于指针太过于灵活和深奥，我们的课程不会讲解指针）

**注意**，我们这里讲解的结构体仅仅是对于数据的封装，而没有涉及到C++中类的部分

## 为什么要使用结构体

如果某一个事物具备了某些性质的话，我们就可以将这一些性质全部打包，让这些独立的事物形成一个逻辑上的整体

而我们所打成这个包就是结构体

更加具体的来说，例如我们要统计班上人员的学号，身高，体重，身份证号的信息，那么我们就我们就可以创造一个新的变量类型，其中包含了一个整数类型来储存学号，两个浮点数类型来储存身高和体重，一个字符串类型类储存身份证号

那么我们创造的这个**新**的**复合**的**变量类型**就叫结构体

例如我们对于1000一个学生的学号，年龄，身高，体重身份证号进行封装

用传统数组方式如下：

```cpp
#define N 1000

int studentID[N];
float height[N];
float weight[N];
std::string ID[N];
```

而使用结构体的定义如下：
```cpp
#define N 1000

struct Student
{
    int studentID;
    float height, weight;
    std::string ID;
} student[N];
```

从逻辑上面来看，我们使用数组的方式是将所有个体的某一个属性打包，然后每个属性在互相分隔。而结构体刚好相反，他是将每个个体打包，个体之间互相分隔

当然，结构体在一定程度上是能够用单独的变量和数组来替换的，但是，这样相较于结构体而言，其逻辑性会下降（但是一切都要放在实际的应用环境中来看待，对于特殊的场景，结构体或许不如数组来的方便直接）

## 如何定义结构体

上面的例子中其实也可以看一个大概

在C/C++中，我们的结构体定义如下：

```cpp
struct tag
{
	member_list;
} variable_list;

struct tag
{
	member_list;
};
tag variable_list;
```

tag是你要定义的结构体名称，就像int、float、double之类的（上面的Student）

member_list是你要结构体存放的变量类型，其可以是自带的变量类型，也可以是其他结构体（上面的studentID，height，weight，ID）

variable_list是你要定义的变量名称（上面的student\[N\]）

还是以存放学生信息为例，我们可以定义如下结构体来存放学生信息:
```cpp
#define N 1000

struct Student
{
    int studentID;
    float height, weight;
    std::string ID;
};
Student student[N];
```

那么在上述代码中，我们创建了一个名字叫Student的结构体，这个结构体包含4个成员变量，一个整数，两个浮点数，一个字符串

并且我们使用这个结构体创建了一个数组student

于是，我们对于每一个student数组中的元素，都包含了这个结构体的四个变量

## 成员访问

在学习初始化前，要首先明白我们应该如何去访问这个结构体中的每一个元素

在访问元素是，我们可以使用“.”（键盘上的点）运算符（成员访问运算符）实现对于结构体中元素的访问

例如：
![[struct student.png]]

可以看到，我们student数组的某个元素后面输入“.”后，弹出了一个框，这个框里面的四个元素恰好全部对应我们前面定义的结构体的四个元素

```cpp
student[1].ID;
```
像这样，我们就能访问结构体里面储存的身份证号码信息

### 初始化

这里涉及到C++中的默认构造函数，不讲，在前期你只需要记住，对于每一个没有**手动**初始化过的结构体变量，你的任何读取操作都是未定义行为，你可能获取到任意的垃圾值

### 输入、输出

与单个变量变量一样，结构体也是可以支持输入输出与赋值的

但是特别要注意，C/C++中的所有输入输出归根结底仅支持三种类型：浮点数，整数，字符串

所以我们的输入输出只能对于当前结构体变量的某一个特定元素操作，而不能直接全部输出这个结构体，代码如下：
```cpp
//合法的：
scanf("%f", &student[0].height);
printf("%d", student[1].studentID);
student[10].height = 10.00;

//不合法的：
scanf("%d", &student[1]);
printf("%f", student[3]);
```

还是那一句话，计算机是很笨的，如果你不给他指明这个事情应该如何去完成，那么他就不知道如何去完成，并且会以报错的形式提示你

### 赋值

在赋值时，我们也可以使用大括号中填写值的方式来对于一个结构体变量快速赋值，但是请一定注意，这里大括号中数据填入的顺序一定是结构体中各个成员的定义顺序，例如我们要对于张三同学的结构体初始化，其代码如下：
```cpp
Student zhangShan;
zhangShan = (Student){123, 1.75, 65.0, "xxxxxxxxxxxxxxxxxx"};
```

一定注意，这里赋值时一定要对于变量进行显式的变量转化（正确来说应该是与类的构造函数、初始化列表有关，由于本课程不涉及类，故将这一过程简单的称为显式转化）

## 内存占用

通常来说，结构体的内存占用为所有变量内存占用的和，但是也有特殊的情况，比如下方的内存对齐

## 内存对齐

这其实是一个无关紧要的话题，你在开发的时候一般不会遇到这种问题（内存管够），不过这仍然是一个实实在在的会造成大量内存空间浪费的实质性问题，这里有必要给大家提出

例如下面代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
  
struct TEST1
{
    bool b1;
    bool b2;
    long long a;
};
struct TEST2
{
    bool b1;
    long long a;
    bool b2;
};
```

大家觉得 TEST1 和 TEST2 的内存占用分别是多少字节？

8，9，10，16，24 ？？？

按照之前的理论，8、9是显然不正确的，因为b1占一字节，b2占一字节，a占8字节，那么至少有10字节

那么答案真的是这样吗？

**既然我都提出来了，那肯定没有这么简单**

我们可以使用 sizeof 运算符查看

```cpp
#include <bits/stdc++.h>
using namespace std;

struct TEST1 {
    bool b1;
    bool b2;
    long long a;
};
  
struct TEST2 {
    bool b1;
    long long a;
    bool b2;
};

int main() {
    cout << "sizeof(TEST1): " << sizeof(TEST1) << endl
         << "sizeof(TEST2): " << sizeof(TEST2) << endl;
    return 0;
}
```

运行结果：
```cpp
sizeof(TEST1): 16
sizeof(TEST2): 24
```

这个结果，其实是分成反直觉的，先不论TEST1 和 TEST2 的占用都远远比10字节空间大，并且两个结构体仅仅是改变了变量的位置，就造成了暂用空间不一样的结果

**计算机世界没有魔法**

这一现象的出现，是因为编译器做了内存对齐这一操作，而至于为什么要做内存对齐，这与现代计算机底层的内存分配方式有关（伙伴系统和slab分配器），内存对齐可以提高结构体中成员的访问速度，这里对于原理不做过多的讲解（没有基础数据结构的加持，你们一定是听不懂的）

### 什么是内存对齐

结构体内存对齐是指当我们创建一个结构体变量时，会向内存申请所需的空间，用来存储结构体成员的内容。我们可以将其理解为结构体成员会按照特定的规则来存储数据内容。

### 内存对齐规则

结构体内存对齐遵循以下基本规则：

1. 第一个成员在相比于结构体变量存储起始位置偏移量为0的地址处。
2. 从第二个成员开始，在其自身对齐数的整数倍开始存储（有的与编译器有关）。
3. 结构体变量所用总空间大小是成员中最大对齐数的整数倍。
4. 当遇到嵌套结构体的情况，嵌套结构体对齐到其自身成员最大对齐数的整数倍，结构体的大小为当下成员最大对齐数的整数倍。

按照这个多级分析，我么就可以很简单的得出上述两个结构体的具体内存分配图：

#### TEST1

b1：1字节
b2：1字节
留空：6字节
a：8字节

总计：16字节
空间浪费率：37.5%

#### TEST2

b1：1字节
留空：7字节
a：8字节
b2：1字节
留空：7字节

总计：24字节
空间浪费率：58.3%

### 节省空间的方式

一个很简单的避免因为内存对齐而造成浪费的方式是让你的结构体定义遵循变量大小由大到小的原则

这样后面的占用较小的变量会尽量利用上前面没有用上的空间

### 时间换取空间

当然，编译器也给了我们选择是否使用内存对齐的自由

使用以下编译指令，就可以不使用内存对齐：
```cpp
#pragma pack(1)
```

```cpp
#include <bits/stdc++.h>
#pragma pack(1)
using namespace std;

struct TEST1 {
    bool b1;
    bool b2;
    long long a;
};

struct TEST2 {
    bool b1;
    long long a;
    bool b2;
};

int main() {
    cout << "sizeof(TEST1): " << sizeof(TEST1) << endl
         << "sizeof(TEST2): " << sizeof(TEST2) << endl;
    return 0;
}
```

这样再运行，TEST1 和 TEST2 所占空间都是 10 字节了

**我们不建议使用这种方式，其虽然优化了空间，但是会付出更大的时间代价**

# 位域

**~~其实这也是一个无关紧要的内容~~**

C/C++作为一个运行在计算机底层的语言，其是否可以定义出比一个字节更小的变量呢？

答案是肯定的，这里我们就可以使用结构体的位域来实现

一个例子是我们使用的网络协议 TCP 协议的头部（偷的CS144）：
![[TCPsegment.png]]
其中：
sport，dport是uint_16
seqno是uint_32
ackno是uint_32
doff是4bit
URG，ACK，PSH，RST，SYN，FIN是1bit
....

显然我们如果用char/bool类型去记录URG之类的变量，在发送的时候再去组装，那势必会浪费时间，于是位域的概念就产生了，我们可以在结构体中精确的定义出某一个位是用来干什么的，并且能像不同的结构体成员变量那样去访问

例如我们就可以定义如下 TCPsegment 的头部
```cpp
struct TCP_header {
    uint16_t sport, dport;
    uint32_t seqno, ackno;
    uint16_t doff : 4;
    uint16_t : 6;
    uint16_t URG : 1, ACK : 1, PSH : 1, RST : 1, SYN : 1, FIN : 1;
    uint16_t win, cksum, uptr;
    uint32_t option;
};
```

使用 sizeof 运算符，可以得到TCP_header的大小位24字节，与预期相符

这样，我们在发送TCP头部的时候，就只需要将这个结构体做定义的变量一次性丢出去就行了，不用再做其他转化

**课件准备的翻车事件：你可以试试把上面的uint_16换成uint_8，再次观察一下内存的使用情况，并且思考出现这种情况的原因（前面已经讲了）**

## 位域的定义

可以看到，位域还是结构体的一个分支内容，基本定义和结构体没有区别
```cpp
struct 位域结构名
{
	位域列表
};
```

要定义位域，只需要将你要定义的变量后面加上一个\':\'，后面再填上需要的空间（bit），那么就完成了位域的定义
```cpp
变量类型 位域名: 位域长度
```

## 位域的使用

再使用是一定要注意以下几点（拿来玩玩就行了，现在你们还不会接触真正的工程项目）：

1. 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的
2. 一个位域必须存储在同一个基本类型所占的空间中，不能跨两个基本类型所占的空间
3. 位域的长度不能大于一个 位域基本类型所占的空间大小 的bit位数
4. 位域字段在内存中的位置是按照从低位向高位的顺序放置的
5. 位域字段不能是类的静态成员（虽然我根本不会给你们讲）
6. 位域不能取地址，因为位域的粒度已经比指针小了（指针的粒度是字节，而位域是位）
7. 由于大小端可能导致的问题（你们学了计组就明白了）

# 永远要相信

你的永远是错的，机器永远是对的

永远不要说所谓的大同小异
[2021.07.13 我们是这样崩的](https://www.bilibili.com/read/cv17521097)（动态类型的锅）
**欧洲航天局阿丽亚娜5号的爆炸**（64位写成16位的运算,造成数据溢出）
**UNIX时间戳**（2038年1月19日03:14:07耗尽,我们仍不知道会发生什么）

## DEBUG的正确姿势

首当其冲的肯定是 GDB，它提供了非常丰富的debug方式，你不仅可以看到源代码、汇编、寄存器，你甚至能拥有暂停整个世界（多线程编程）和反向执行代码的能力（由下至上执行）。但是命令行的方式入门难度较大

另外我们常用的 DEBUG 方式如下：
1. 直接printf输出中间过程的值（当然提交的时候得删掉）
2. assert断言某个条件一定成立（防御性编程）
3. 边界情况测试（比如润年，边界情况就是2/29）
4. 颅内编译运行（你们目前的代码量肯定不能支持你们这么干）
5. **墙裂**建议大家打开编译器的 -Wall -Werror选项，能帮助你发现非常多的问题！（怎么开不同 IDE 不一样，百度一下就行：xxx如何开启编译选项）

下面我们就以 VJ 第一次练习 E 题来给大家示范