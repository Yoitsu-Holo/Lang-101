# 计算机的存储结构

在了解计算机内存之前，要首先了解计算机的存储结构以及各个结构的数据访问速度关系

| 名称 | 速度 | 容量 | 作用 |
|--|--|---|--|
| Register 寄存器 | 最快，小于纳秒 | 几个 | 当前正在运算的数据 |
| Cache 缓存 | 很快,纳秒级 | 最小,MB | 作为CPU运算的临时存储 |
| Memory 内存 | 较快,微秒级 | 较大,GB | 存储所有运行的程序 |
| Disk 磁盘(外存) | 较慢,毫秒级 | 最大,TB | 存储程序信息 |

![[storage_level.png]]

上面的几种存储器件共同组成了计算机的储存系统

其基本单位是位（bit）
通常 8bit 构成一个字节（Byte/B）
2^10个字节构成一个千字节（KiB）
2^10个千字节构成一个兆字节（MiB）
2^10个兆字节构成一个吉字节（GiB）

1GiB=1024MiB；1MiB=1024KiB
1KiB=1024B；1B=8bit

小知识，这里其实很多地方都使用存在误解的标注，包括 windows 系统，GiB和GB的含义是不一样的，前者是1024为进制，后者是1000为进制（Linux就做的很好）

### 内存

程序的运行必须要有来存放相关数据的空间，显然，程序是较为庞大的，不能直接放进CPU的cache缓存里面（这个区域通常只有几百Kb~几十Mb），又因为我们磁盘的读写效率和与CPU的距离等因素，程序是不能直接运行在磁盘上的，否者运行效率将大打折扣（大部分时间都在访问数据，而不是程序本身的执行），所以，我们需要内存来作为我们程序运行的一个桥梁

当我们执行一个程序的时候，操作系统会将这个程序的关键部分全部加载在内存中，然后再内存中运行这个程序

## 内存地址

我们知道内存这个东西之后，就会想要知道如何去访问内存里面的具体数据，于是我们就将内存像地图上的区域划分一样，赋予其一个独一无二的内存地址，这样我们就可以通过这个独一无二的地址去访问这一块内存所存储的值

当然，我这这里不考虑现代操作系统中的地址虚拟化技术，我们认为一个程序就在一个独一无二的地址空间就行了

# 数组

好，在了解基本存储器的常识之后，我们就可以进入到数组的学习了

## 什么是数组

数组（Array）**是有序的元素序列**

若将有限个类型相同的变量的集合命名，那么这个名称为数组名

组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标

数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按有序的形式组织起来的一种形式

这些有序排列的同类数据元素的集合称为数组

比如弹链，就非常像一个数组：连续，有序，独立，有限

![[belt.array.jpeg]]

合理利用数组可以大大增加代码的可读性可简洁性，这种优势在大量具有相同特性的数据是体现的极为明显

例如，我们要保存全体学生的身高信息，我们就可以建立一个浮点数的数组，利用学生的学号作为数组的下标，其数组中的每一个元素存储一个浮点数代表每一个学生的身高（尽管这是一种不太节约空间的方式）

注意上方的细节，首先我们用的学号代表了每一个学生，显然学号和学生之间存在一一对应的关系，这时我们才能利用学号来代替学生

其次，学号是一个整数，而数组的下标也必须是一个整数

而数组本身的信息可以千变万化，上面我们是用的浮点数，我么也可以直接用整数存储，或者直接以字符串的形式记录身高都是可行的

## 如何创建数组

在C/C++中，提供了非常方便的数组(一维)建立方式

格式为：变量类型  数组名字\[数组大小\];
这里的变量类型也可以是我们下节课会讲到的结构体

代码如下

```cpp
int a[1000];
```

这里我们是建立了一个**元素个数为1000个**并且**每一个元素是int类型**的**一维数组**，其下标范围是0~999

为什么说是一维呢，因为其只有一个下标，那么从逻辑上讲就是线性的

### 内存中的数组

前面已经讲过，任何程序都是在内存中执行的，那么我们就有必要来考虑数组在内存中的具体存储方式

一段连续的内存区域，每一个方块代表了一个字节：

![[array1.png]]

前面我们已经知道，一个int类型的变量占据了4个字节

那么同样，我们int数组中的一个元素也占据了**独立的4个字节**，并且对于数组中的元素而言，相邻元素占据的内存也是从逻辑上是相邻的（物理上不相邻）

具体而言，**如果**a[1]占据的内存是{3,4,5,6}这么4个字节，那么a[2]占据的一定是{7,8,9,10}这么4个字节(这里只是作为一个简单的讲解，并非实际情况)

同样，我么可以使用内存模型来解释为什么数组下标是从0开始而不是1开始的

在实验之前，我们要明白数组名所对应的其实是当前数组最开始的内存地址（这里也解释了为什么字符串在读入时不用写&取地址符），数组下标存放的其实是地址的偏移量

### 数组实验

```cpp
int a[1000];
printf("Add,a:%d Add,a[0]%d\n", a, &a[0]);
printf("a[0]:%d\n", &a[0]);
printf("a[1]:%d\n", &a[1]);
printf("a[2]:%d\n", &a[2]);
printf("a[10]:%d\n", &a[10]);
```
运行结果
```txt
Add,a:6418048 Add,a[0]6418048
a[0]:6418048
a[1]:6418052
a[2]:6418056
a[10]:6418088
```

可以看到，在第一行，我们直接输出a的地址和输出a[0]的地址，这两个值是完全相同的

从第二行到第四行我们可以推断出，数组下标每相差1，在内存区域上就间隔了这个元素所需的内存空间的大小（一个int占4字节）

那么由
address a[0]=6418048可以合理推断出
address a[10]应该为6418088
实际上也正是如此

那么我们上方的内存模型就可以变成下面这个样子：
![[array2.png]]

## 高维数组

上方我们介绍的是一维的数组，那么有一维是否有二维呢？

答案是肯定的，并且在此基础上，可以发展出更高维的数组

其具体定义方式和访问方式与一维数组及其相似，我们以二维和三维数组为例子就行了
```cpp
    int a[1000][1000];  //二维数组的定义
    int b[10][10][10];  //三维数组的定义
```
因为高维数组与一维数组具有相似性，所以课程后面全部以一维数组的方式来讲解

## 数组的赋值、初始化

前面的课程我们已经知道，对于单个变量我们可以直接使用等号进行赋值来达到对它的初始化操作，那么数组应该如何初始化？

最直接最通用的方式就是直接对一个元素赋值，代码如下：
```cpp
    a[45] = 100;
```
还有一种用于数组定义的时候统一赋值，其代码如下：
```cpp
    int a[1000]={1,3,2,4,5};
```
这种赋值方式就是将后方大括号中的值依次序填入a[0],a[1],a[2]…，当大括号的值填完后，后面统一填入0（因此可以只写一个大括号，系统会将所有值填为0）

对于二维数组来说是这样的：
```cpp
    int a[10][10]={{1,2,3},{3,2,5,6}};
```
简单来说就是有几维就应该有几层括号

又或者我们上次课学习的循环可以来帮助我们更加直观的完成这个事情，例如我们要将a数组的下标为1~100的元素全部初始化为10，我们就可以使用以下代码来解决：
```cpp
for(int i = 1; i <= 100; i++)
	a[i] = 10;
```

## 数组的输入输出

前面已近说过，数组中的单个元素就是一个普通的变量，所以我们对于每一个确定的元素使用和单个变量完全一样的输入输出方式

例如对于一个一维的整数数组
```cpp
for (int i = 1; i <= 100; i++) {
    scanf("%d", &a[i]);
} //批量读入
for (int i = 1; i <= 100; i++) {
    printf("%d\n", a[i]);
} //批量输出
```

## 数组的运算

同样，先要确定书数组中的哪一个元素，然后和普通的变量一样运算即可

例如我们要统计0~i的数字和，并且对于每一个i都要记录，那么我们就可以使用以下代码实现：

```cpp
int a[101];
a[0]=0;
for(int i = 1; i <= 100; i++)
	a[i] = a[i-1] + i;
```

## 数组的空间占用

在使用数组的时候，应该值得注意的是数组的大小，其大小可以用以下公式计算：
各个维度的大小乘积 * 元素所占用的内存 / 1024

最终的计算的结果是KiB
例如我们以渲染一张8k分辨率（7680x4320），10bit色深的图片为例
其如果用数组储存，每一个像素包含RGB三个颜色通道，每一个通道占用10bit，那么一共占用30bit，可以近似用int类型来存贮，为了储存这个图片，我们就要用到一个7680\*4320大小的int类型数组来存储，其数组大小就达到了127M，当然这是很粗略的估算，但也能从一定程度上解释了为什么在运行高分辨率的运行程序的时候，显卡显存占用会非常高（显存也是一种内存）

而这里的内存做占用的空间也就是我们后面会经常遇到的**空间复杂度**

## 数组越界

数组的大小决定了你能够有效访问的数组下标，例如，a数组的大小是10，那么你能够合法访问的最大下标就是9，如果你访问到了10,乃至更大，就造成了数组越界，越界能导致非常多的错误发生，例如返回错误数值，程序直接崩溃等等

```cpp
#include <cstdio>

using namespace std;
int a[5] = {1, 2, 3, 4, 5};
int main() {
    int pos;
    while (scanf("%d", &pos))
        printf("out: %d\n", a[pos]);
}
```

依次输入0,1,2,3,4,5,6,7,8

在我的机器上的运行结果为：
```txt
out:1
out:2
out:3
out:4
out:5
out:0
out:0
out:0
out:4253552
```

显然，到后面越界时，返回的结果是一个不可信的垃圾值

注意，不同的编译器对于越界的宽容性不一样，越界后返回结果也不一样，自行实验时只要前面未越界部分值一样就行，只要越界，那么后面的值一定是不可信的垃圾值！！！

# 总结

数组在程序中用到的范围非常广泛，应该熟练掌握

数组的赋值方式也是多样的，每一种都会在程序中经常用到

但是一定要注意，数组的大小要严格把控，切记不可随意申请，尽量做到需要多少申请多少，不要申请过小导致数组越界，也不可能申请过大导致内存占用过高

# 关于OJ的使用

OJ，全称Online Judge，是我们常用的在线代码评测方式（你们期末期中考试同样使用OJ）。它的基本原理就是将你的代码放在服务器上并且运行在隔离的环境中，通过一系列的监控程序监控你代码的运行状态。并且OJ会提供程序的输入，对比你程序的输出来判断你的程序是否能够满足运行需求。

在使用OJ的时候一定要注意以下两个题目指标：内存限制、时间限制

一般而言，我们的代码内存要求在256M之内，时间在1s之内。

另外OJ做题要注意以下几点：
- OJ返回的评测结果
- 多组数据的读入

## 返回结果

一般而言，你们可能会碰到如下结果：

| 结果 | 含义(真) | 含义(误) |
|---|---|---|
| AC | Accept | Answer Correct |
| CE | Compile Error | Compile Easily |
| PC | Partially Correct | Pass Compile |
| PE | Presentation Error | Pass Easily |
| WA | Wrong Answer | Wonerful Answer |
| RE | Runtime Error | Right Enough |
| TLE | Time Limit Exceeded | Time Limit Enough |
| MLE | Memory Limit Exceeded | Memory Limit Enough |
| OLE | Output Limit Exceeded | Output Limit Enough |
| UKE | Unknown Error Exceeded | Unknown Exactness |

这个错误信息非常重要，很多时候能非常快的告诉你程序可能发生的问题，例如：
- TLE：尝试优化你的算法运行时间
- MLE：请减少内存占用
- OLE：你的输出可能卡在一个死循环
- RE：可能是数组越界，函数调用错误等等
- PE：答案对，但是格式不对，检查空格和换行（**学校OJ特别卡这个**）

爆零是一种宿命， 枚举是一种思想
打表是一种勇气， 骗分是一种日常
刷题是一种出路， AC是一种原谅
AK是一种梦想， 搜索是一种信仰
剪枝是一种精神， 弃赛是一种颓废
吊打是一种必然， 入队是一种奢望
![[Pasted image 20220908090645.png]]

## 多组数据的读入

一般而言，我们会遇到以下两种多组数据的描述：

1. 第一行包含一个数字 T，表示有 T 组数据，每组数据格式如下...
2. 程序输入包含多组数据，每组数据如下...

对于第一种告诉了你具体数据组数的样例，你的代码可能如下：

```cpp
int main() {
	int T;
	scanf("%d",&T);
	while(T--) {
		...    // 你的代码
	}
}
```

对于第二种，由于没有告诉具体的数据组数，那么你就得读到文件末尾，你有两种选择(我们建议)：

```cpp
int main() {
	while( scanf(...)!=EOF ) {
		...;
	}
}
```

```cpp
int main() {
	while( cin>>... ) {
		...;
	}
}
```

关于更多的信息，这里放一个洛谷的帮助中心链接，OJ都大差不差
https://www.luogu.com.cn/blog/luogu/luogu-help

# 关于提问

上节课我已经说过，前期的语法不再提供售后，如果还有基础语法问题，请大家自行解决，这么干有如下原因：
1. 后面开始做题，大量的同学会遇到OJ问题，如果还在问语法问题，那么会相当浪费时间
2. 语法前面虽然有缺漏，但是应付你们现在的基础题目是完全够用的，前提是你仔细研究，仔细品
3. 绝大部分的编译问题都可以通过IDE的报错或者警告信息**非常快**的定位到错误点，动动小手，复制到百度翻译自己看一下，浪费不了几秒钟
4. 当然，如果遇到奇怪的问题还是可以问

如果你实在有问题要来问我，那么请通过邮箱联系：
YoitsuHolo@outlook.com

这么做不是没事找事，而是考虑到有如下优点：
1. 邮箱你就不要想像qq一样可以马上回复，啥看到了就啥时候回，如果你经得起等，那没问题。如果你想快点解决，那就靠自己！
2. 发邮件像写信一样，要求你尽量一次性将问题描述的足够清楚，永远记住，你提供的信息越多，收到的回复就越准确。
3. 邮件可以添加附件，例如你们的源代码可以一并通过附件发送，方便对方解答

这里特别建议你们去看看**黄兆宇**学长发的两本手册：
How to ask
智慧的提问